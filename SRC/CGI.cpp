#include "../INCLUDES/CGI.hpp"
#include <sstream>

CGI::CGI(const char *RequestType,
		const char *FilePath,
		const char *Language,
		const char *CgiBinary,
		const char **Env) : requestType(RequestType),
		Filepath(FilePath), language(Language),
		cgiBinary(CgiBinary), env(Env)
{
	execArg = new char*[3];
	execArg[0] = const_cast<char *>(cgiBinary);
	execArg[1] = const_cast<char *>(Filepath);
	execArg[2] = NULL;
	file.open("./SRC/temp/temp.txt", std::ios::out);
}

bool CGI::CGIProccess()
{
	int lvl = -1;
	std::string s = this->language;
	std::string supported[2] = {".php", ".py"}; // addable..
	for (int i = 0; i < NSCGI; i++)
	{
		if (s == supported[i])
		{
			lvl = i;
			break;
		}
	}
	switch (lvl){
		case PHP:
			break;
		case PYTHON:
			break;
		default:
			return false;
	}
	if (CGIOutput())
		return false;
	responseWrapper();
	return true;
}

int CGI::wrireToFile(std::ofstream &file, char *str)
{
    if (!str)
        return std::cout << "didn't write to file\n", 1;
    file <<  str;
    return 0;
}

int CGI::CGIOutput()
{
    pid_t id;
    int status;
    int piped[2];
    std::ofstream file("temp.txt");

    if (pipe(piped) == -1)
        return std::cerr << "pipe failed\n", 1;
    id = fork();
    if (id == -1)
        return std::cerr << "fork failed\n", 1;
    if (id == 0)
    {
        close(piped[0]);
        dup2(piped[1], 1);
        close(piped[1]);
        execve(cgiBinary, execArg, (char **)env);
        return 1;
    }
    close(piped[1]);

    char buffer[4096];
    int totalRead = 0;
    int bytesRead;
    
    while ((bytesRead = read(piped[0], buffer, sizeof(buffer) - 1)) > 0)
    {
        buffer[bytesRead] = '\0';
        file << buffer;
        totalRead += bytesRead;
    }
    
    if (waitpid(id, &status, 0) == -1)
        return 1;
        
    if (totalRead == 0)
        return std::cerr << "couldn't read CGI output\n", 1;
    
    close(piped[0]);
    file.close();
    return 0;
}

// Content-type: text/html

// <!DOCTYPE html>
// <html>
// <head>
//     <title>CGI Example</title>
// </head>
// <body>
//     <h1>Hello from CGI!</h1>
//     <p>This is a simple HTML response generated by a CGI script.</p>
// </body>
// </html>

int CGI::responseWrapper()
{
	std::string statusLine = "HTTP/1.1 200 OK\r\n";
	std::ifstream file("temp.txt");
	std::stringstream output;
	output << file.rdbuf();
	std::string lines = output.str();
	file.close();
	
	std::cout << "---lines---\n";
	std::cout << lines << std::endl;

	// TODO: Check if CGI script already provided headers
	if (lines.find("Content-Type:") != lines.npos)
	{
		response = statusLine + lines;
	}
	else
	{
		std::ostringstream contentLengthStream;
		contentLengthStream << lines.length();
		std::string header =
			"Content-Type: text/html\r\n"
			"Content-Length: " + contentLengthStream.str() + "\r\n\r\n";

		response = statusLine + header + lines;
	}
	std::cout << "----response----\n" << response << std::endl;
	return 0;
}

CGI::~CGI()
{
	delete[] execArg;
}