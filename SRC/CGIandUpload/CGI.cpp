#include "../../INCLUDES/CGI.hpp"

CGI::CGI(const char *RequestType,
		const char *FilePath,
		const char *Language,
		const char *CgiBinary,
		const char **Env) : requestType(RequestType),
		Filepath(FilePath), language(Language),
		cgiBinary(CgiBinary), env(Env)
{
	execArg = new char*[3];
	execArg[0] = const_cast<char *>(cgiBinary);
	execArg[1] = const_cast<char *>(Filepath);
	execArg[2] = NULL;
	file.open("temp.txt", std::ios::out);
}

bool CGI::CGIProccess()
{
	int lvl = -1;
	std::string s = this->language;
	std::string supported[2] = {".php", ".py"}; // addable..
	for (int i = 0; i < NSCGI; i++)
	{
		if (s == supported[i])
		{
			lvl = i;
			break;
		}
	}
	switch (lvl){
		case PHP:
			break;
		case PYTHON:
			break;
		default:
			return false;
	}
	if (CGIOutput())
		return false;
	responseWrapper();
	return true;
}

int CGI::wrireToFile(std::ofstream &file, char *str)
{
    if (!str)
        return std::cout << "didn't write to file\n", 1;
    file <<  str;
    return 0;
}

int CGI::CGIOutput()
{
    pid_t id;
    int status;
    int piped[2];
    std::ofstream file("temp.txt");

    if (pipe(piped) == -1)
        return std::cerr << "pipe failed\n", 1;
    id = fork();
    if (id == -1)
        return std::cerr << "fork failed\n", 1;
    if (id == 0)
    {
        close(piped[0]);
        dup2(piped[1], 1);
        close(piped[1]);
        execve(cgiBinary, execArg, (char **)env);
        return 1;
    }
    if (waitpid(id, &status, 0) == -1)
        return 1;
    char s[1024] = {0};
    int readen = read(piped[0], s, 1023);
    if (readen == -1 || readen == 0)
        return std::cerr << "coudn't read\n", 1;
    s[readen] = '\0';
    wrireToFile(file, s);
    close(piped[0]);
	file.close();
    return 0;
}

// Content-type: text/html

// <!DOCTYPE html>
// <html>
// <head>
//     <title>CGI Example</title>
// </head>
// <body>
//     <h1>Hello from CGI!</h1>
//     <p>This is a simple HTML response generated by a CGI script.</p>
// </body>
// </html>

int CGI::responseWrapper()
{
	std::string statusLine = "HTTP/1.1 200 OK\r\n";
	std::ifstream file("temp.txt");
	std::stringstream output;
	output << file.rdbuf();
	std::string lines = output.str();
	if (lines.find(':', 0))
	{
		std::string header =
			"Content-Type: text/html\r\n"
			"Content-Length: " + std::to_string(lines.length()) + "\r\n\r\n";

		response += "\r\n";
		response += statusLine;
		response += header;
		response += lines;
	}
	file.close();
	return 0;
}

CGI::~CGI()
{
	delete[] execArg;
}